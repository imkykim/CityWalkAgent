#!/usr/bin/env python3
"""
Command-line entrypoint for running the CityWalkAgent pipeline.

This script wraps the high-level pipeline orchestrator with a friendly CLI so
you can kick off end-to-end analyses (route generation → image collection →
VLM scoring → sequential analytics) or re-run the workflow on an existing route.
"""

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import Tuple, Optional

# Ensure local src/ package is importable when executed as a script
REPO_ROOT = Path(__file__).resolve().parent
SRC_DIR = REPO_ROOT / "src"
if str(SRC_DIR) not in sys.path:
    sys.path.insert(0, str(SRC_DIR))

from pipeline import WalkingAgentPipeline, PipelineResult  # noqa: E402
from config import settings  # noqa: E402


def _parse_coord(value: str) -> Tuple[float, float]:
    """Parse a latitude,longitude string into a float tuple."""
    try:
        lat_str, lon_str = value.split(",", maxsplit=1)
        return float(lat_str.strip()), float(lon_str.strip())
    except ValueError as exc:
        raise argparse.ArgumentTypeError(
            "Coordinates must be in 'lat,lon' format (e.g., 40.7589,-73.9851)"
        ) from exc


def _build_parser() -> argparse.ArgumentParser:
    """Configure CLI arguments."""
    parser = argparse.ArgumentParser(
        description="Run the CityWalkAgent walking-experience analysis pipeline.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    group = parser.add_mutually_exclusive_group(required=False)
    group.add_argument(
        "--route-file",
        type=Path,
        help="Path to an existing route JSON file generated by the pipeline.",
    )
    group.add_argument(
        "--start",
        type=_parse_coord,
        help="Starting coordinate as 'lat,lon'. Requires --end.",
    )
    group.add_argument(
        "--route-folder",
        type=Path,
        help="Path to a pre-collected route folder (requires collection_metadata.json).",
    )

    parser.add_argument(
        "--end",
        type=_parse_coord,
        help="Ending coordinate as 'lat,lon'. Required unless --route-file is used.",
    )
    parser.add_argument(
        "--interval",
        type=int,
        default=settings.default_sampling_interval,
        help="Sampling interval between waypoints (meters).",
    )
    parser.add_argument(
        "--route-name",
        type=str,
        help="Optional name for the generated route.",
    )
    parser.add_argument(
        "--framework",
        type=str,
        default=settings.default_framework_id,
        help="Framework identifier to drive evaluation prompts.",
    )
    parser.add_argument(
        "--provider",
        type=str,
        default="claude",
        help="VLM provider name (claude, openai, qwen).",
    )
    parser.add_argument(
        "--model",
        type=str,
        help="Override model name for the selected provider.",
    )
    parser.add_argument(
        "--api-key",
        type=str,
        help="Explicit API key; falls back to environment settings if omitted.",
    )
    parser.add_argument(
        "--max-concurrent",
        type=int,
        default=5,
        help="Maximum concurrent VLM requests.",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        help="Directory to store pipeline outputs (defaults to settings.results_dir/pipeline).",
    )
    parser.add_argument(
        "--skip-images",
        action="store_true",
        help="Skip image collection (assumes waypoints already have image paths).",
    )
    parser.add_argument(
        "--disable-cost-tracking",
        action="store_true",
        help="Disable API cost tracking (useful when dependencies are unavailable).",
    )

    # Agent mode arguments
    parser.add_argument(
        "--agent",
        action="store_true",
        help="Enable agent mode (uses personality-driven analysis).",
    )
    parser.add_argument(
        "--personality",
        type=str,
        default="balanced",
        help="Personality preset to use in agent mode (safety, scenic, balanced, etc.).",
    )
    parser.add_argument(
        "--use-semantic",
        action="store_true",
        default=True,
        help="Use semantic mapping for personality (adapts to any framework).",
    )
    parser.add_argument(
        "--no-use-semantic",
        dest="use_semantic",
        action="store_false",
        help="Use framework-specific personality configuration instead of semantic mapping.",
    )
    parser.add_argument(
        "--list-personalities",
        action="store_true",
        help="List available personality presets and exit.",
    )

    return parser


def _run_pipeline(args: argparse.Namespace) -> PipelineResult:
    """Instantiate and execute the walking agent pipeline."""
    pipeline = WalkingAgentPipeline(
        framework_id=args.framework,
        vlm_provider=args.provider,
        vlm_api_key=args.api_key,
        vlm_model=args.model,
        max_concurrent=args.max_concurrent,
        output_dir=args.output_dir,
        enable_cost_tracking=not args.disable_cost_tracking,
    )

    if args.route_file:
        return pipeline.analyze_existing_route(args.route_file)

    if args.route_folder:
        raise ValueError("--route-folder is only supported in agent mode.")

    if args.start is None or args.end is None:
        raise ValueError("Both --start and --end must be provided when not using --route-file.")

    return pipeline.analyze_route(
        start=args.start,
        end=args.end,
        interval_meters=args.interval,
        route_name=args.route_name,
        collect_images=not args.skip_images,
    )


def _list_personalities() -> None:
    """Print available personality presets and their configurations."""
    from agent import list_presets, get_preset
    from config import settings

    print("\n=== Available Agent Personalities ===\n")

    presets = list_presets()
    framework_id = settings.default_framework_id

    for preset_name in presets:
        try:
            # Get personality with semantic mapping
            personality = get_preset(preset_name, framework_id, use_semantic=True)

            print(f"• {preset_name.upper()}")
            print(f"  Name: {personality.name}")
            print(f"  Description: {personality.description}")
            print(f"  Explanation Style: {personality.explanation_style}")
            print(f"  Dimension Weights:")
            for dim, weight in sorted(personality.dimension_weights.items()):
                print(f"    - {dim}: {weight:.2f}")
            print()

        except Exception as e:
            print(f"• {preset_name.upper()}: Error loading ({e})")
            print()

    print(f"Use with: python main.py --agent --personality <name> --start LAT,LON --end LAT,LON")
    print(f"Example:  python main.py --agent --personality safety --start 40.7,-73.9 --end 40.8,-73.8\n")


def _run_agent(args: argparse.Namespace) -> dict:
    """Run agent-based route analysis."""
    from agent import WalkingAgent

    print(f"\n=== Agent Mode: {args.personality.title()} ===\n")

    # Create agent from preset
    agent = WalkingAgent.from_preset(
        preset_name=args.personality,
        framework_id=args.framework,
        use_semantic=args.use_semantic,
    )

    print(f"Agent: {agent.metadata.name}")
    print(f"Description: {agent.metadata.description}")
    print(f"Framework: {args.framework}")
    print(f"Configuration: {'Semantic mapping' if args.use_semantic else 'Framework-specific'}")
    print()

    if args.route_folder:
        if args.start is not None or args.end is not None:
            raise ValueError("Provide either --route-folder or --start/--end, not both.")

        route_folder = args.route_folder.resolve()
        print(f"Analyzing existing route folder: {route_folder}")
        print(f"Interval override: {args.interval} meters (if provided)\n")

        result = agent.run(
            route_folder=route_folder,
            interval=args.interval,
        )
    else:
        # Validate coordinates
        if args.start is None or args.end is None:
            raise ValueError("Both --start and --end must be provided in agent mode.")

        # Run agent
        print(f"Analyzing route from {args.start} to {args.end}...")
        print(f"Interval: {args.interval} meters\n")

        result = agent.run(
            start=args.start,
            end=args.end,
            interval=args.interval,
        )

    return result


def _print_summary(result: PipelineResult) -> None:
    """Render a short, human-readable summary of the pipeline outputs."""
    print("\n=== CityWalkAgent Pipeline Complete ===")
    print(f"Route ID:          {result.route_id}")
    print(f"Waypoints:         {result.route_info['waypoints']}")
    print(f"Sequential Pattern:{result.sequential_analysis['pattern_type']}")
    print(f"Hidden Barriers:   {len(result.sequential_analysis['hidden_barriers'])}")
    print(f"Better Method:     {result.method_comparison['which_method_better']}")
    print("\nOutput Files:")
    for label, path in result.output_files.items():
        print(f"  - {label}: {path}")
    print("\nDone!")


def _print_agent_summary(result: dict) -> None:
    """Render a human-readable summary of agent analysis results."""
    print("\n=== Agent Analysis Complete ===")

    # Route info
    perception = result.get("perception", {})
    route_info = perception.get("route_info", {})
    print(f"Route ID:          {route_info.get('route_id', 'N/A')}")
    print(f"Images Evaluated:  {route_info.get('num_images', 0)}")

    # Decision info
    decision = result.get("decision", {})
    action = result.get("result", {})

    print(f"\nRecommendation:    {decision.get('recommendation', 'N/A').upper()}")
    print(f"Confidence:        {decision.get('confidence', 0):.1%}")
    print(f"Weighted Score:    {decision.get('weighted_score', 0):.2f}/10")

    # Sequential analysis
    seq_analysis = decision.get("sequential_analysis", {})
    if seq_analysis:
        print(f"Route Pattern:     {seq_analysis.get('pattern_type', 'N/A')}")
        print(f"Volatility:        {seq_analysis.get('volatility', 0):.2f}")
        print(f"Hidden Barriers:   {len(seq_analysis.get('hidden_barriers', []))}")

    # Explanation
    print(f"\n{action.get('message', 'No explanation available')}")

    # Highlights
    highlights = decision.get("highlights", [])
    if highlights:
        print(f"\n✨ Highlights:")
        for highlight in highlights[:3]:
            print(f"   • {highlight}")

    # Concerns
    concerns = decision.get("concerns", [])
    if concerns:
        print(f"\n⚠️  Concerns:")
        for concern in concerns[:3]:
            print(f"   • {concern}")

    # Agent state
    state = result.get("state", {})
    print(f"\nAgent Memory:      {state.get('memory_count', 0)} experiences")

    print("\nDone!")


def main(argv: Optional[list[str]] = None) -> int:
    """Main CLI entrypoint."""
    parser = _build_parser()
    args = parser.parse_args(argv)

    # Handle --list-personalities
    if args.list_personalities:
        _list_personalities()
        return 0

    # Run in agent or pipeline mode
    try:
        if args.agent:
            result = _run_agent(args)
            _print_agent_summary(result)
        else:
            result = _run_pipeline(args)
            _print_summary(result)
    except Exception as exc:
        mode = "Agent" if args.agent else "Pipeline"
        print(f"\n{mode} failed: {exc}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
