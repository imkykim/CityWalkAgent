#!/usr/bin/env python3
"""
Command-line entrypoint for running the CityWalkAgent pipeline.

This script wraps the high-level pipeline orchestrator with a friendly CLI so
you can kick off end-to-end analyses (route generation → image collection →
VLM scoring → sequential analytics) or re-run the workflow on an existing route.
"""

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import Tuple, Optional

# Ensure local src/ package is importable when executed as a script
REPO_ROOT = Path(__file__).resolve().parent
SRC_DIR = REPO_ROOT / "src"
if str(SRC_DIR) not in sys.path:
    sys.path.insert(0, str(SRC_DIR))

from pipeline import WalkingAgentPipeline, PipelineResult  # noqa: E402
from config import settings  # noqa: E402


def _parse_coord(value: str) -> Tuple[float, float]:
    """Parse a latitude,longitude string into a float tuple."""
    try:
        lat_str, lon_str = value.split(",", maxsplit=1)
        return float(lat_str.strip()), float(lon_str.strip())
    except ValueError as exc:
        raise argparse.ArgumentTypeError(
            "Coordinates must be in 'lat,lon' format (e.g., 40.7589,-73.9851)"
        ) from exc


def _build_parser() -> argparse.ArgumentParser:
    """Configure CLI arguments."""
    parser = argparse.ArgumentParser(
        description="Run the CityWalkAgent walking-experience analysis pipeline.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    group = parser.add_mutually_exclusive_group(required=False)
    group.add_argument(
        "--route-file",
        type=Path,
        help="Path to an existing route JSON file generated by the pipeline.",
    )
    group.add_argument(
        "--start",
        type=_parse_coord,
        help="Starting coordinate as 'lat,lon'. Requires --end.",
    )

    parser.add_argument(
        "--end",
        type=_parse_coord,
        help="Ending coordinate as 'lat,lon'. Required unless --route-file is used.",
    )
    parser.add_argument(
        "--interval",
        type=int,
        default=settings.default_sampling_interval,
        help="Sampling interval between waypoints (meters).",
    )
    parser.add_argument(
        "--route-name",
        type=str,
        help="Optional name for the generated route.",
    )
    parser.add_argument(
        "--framework",
        type=str,
        default=settings.default_framework_id,
        help="Framework identifier to drive evaluation prompts.",
    )
    parser.add_argument(
        "--provider",
        type=str,
        default="claude",
        help="VLM provider name (claude, openai, qwen).",
    )
    parser.add_argument(
        "--model",
        type=str,
        help="Override model name for the selected provider.",
    )
    parser.add_argument(
        "--api-key",
        type=str,
        help="Explicit API key; falls back to environment settings if omitted.",
    )
    parser.add_argument(
        "--max-concurrent",
        type=int,
        default=5,
        help="Maximum concurrent VLM requests.",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        help="Directory to store pipeline outputs (defaults to settings.results_dir/pipeline).",
    )
    parser.add_argument(
        "--skip-images",
        action="store_true",
        help="Skip image collection (assumes waypoints already have image paths).",
    )
    parser.add_argument(
        "--disable-cost-tracking",
        action="store_true",
        help="Disable API cost tracking (useful when dependencies are unavailable).",
    )

    return parser


def _run_pipeline(args: argparse.Namespace) -> PipelineResult:
    """Instantiate and execute the walking agent pipeline."""
    pipeline = WalkingAgentPipeline(
        framework_id=args.framework,
        vlm_provider=args.provider,
        vlm_api_key=args.api_key,
        vlm_model=args.model,
        max_concurrent=args.max_concurrent,
        output_dir=args.output_dir,
        enable_cost_tracking=not args.disable_cost_tracking,
    )

    if args.route_file:
        return pipeline.analyze_existing_route(args.route_file)

    if args.start is None or args.end is None:
        raise ValueError("Both --start and --end must be provided when not using --route-file.")

    return pipeline.analyze_route(
        start=args.start,
        end=args.end,
        interval_meters=args.interval,
        route_name=args.route_name,
        collect_images=not args.skip_images,
    )


def _print_summary(result: PipelineResult) -> None:
    """Render a short, human-readable summary of the pipeline outputs."""
    print("\n=== CityWalkAgent Pipeline Complete ===")
    print(f"Route ID:          {result.route_id}")
    print(f"Waypoints:         {result.route_info['waypoints']}")
    print(f"Sequential Pattern:{result.sequential_analysis['pattern_type']}")
    print(f"Hidden Barriers:   {len(result.sequential_analysis['hidden_barriers'])}")
    print(f"Better Method:     {result.method_comparison['which_method_better']}")
    print("\nOutput Files:")
    for label, path in result.output_files.items():
        print(f"  - {label}: {path}")
    print("\nDone!")


def main(argv: Optional[list[str]] = None) -> int:
    """Main CLI entrypoint."""
    parser = _build_parser()
    args = parser.parse_args(argv)

    try:
        result = _run_pipeline(args)
    except Exception as exc:
        print(f"\nPipeline failed: {exc}", file=sys.stderr)
        return 1

    _print_summary(result)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
